Согласно задания производим анализ работы приложения с помощью доступных нам инструментов.

0. Запускаем приложение и при помощи команды "jps" в терминале, получаем id запущеного приложения: 11740;

1. Используем команду "jmap -histo 11740" в трех случаях:
    1.0 Сразу после запуска приложения, когда не были созданы заявки;
    1.1 После создания 100000 заявок и загрузки их в память;
    1.2 После удаления 90000 заявок;
Получаем следующий результат:
После запуска программы, создано большое количество объектов различных классов, не относящихся к получаемым от пользователя данным, модуля java.base.
При этом, повторное использование утилиты jmap показывает, что без дальнейших действий со стороны пользователя, не происходит увеличение количества объектов и не увеличиваются затраты памяти.
После добавления 100000 заявок, в память было загружено больше 700000 новых объектов, таких как String, LocalDateTime, используемых в используемом пользователем классе Item.
Количество объектов увеличилось в 12,767 раз, тогда как количество байт используемой памяти увеличилось в 4,375 раз, что может говорить о том, что загружаемые в память объекты класса Item (и подтягиваемые им объекты) не столь "тяжеловесны" по сравнению с другими.
Также мы можем заметить созданные один раз в процессе использования программы объекты классов Action, Input,Output, MemTracker и другие. Однако общее количество используемых в программе классов уменьшилось с 685 до 590.
Помимо этого увеличилось количество объектов класса "[B", а количество объектов класса "[I" уменьшилось. (#Пометка_для_себя: разобраться, что это за класса [B, [D, [S, [I...)
... А! Разобрался. Это примитивы. Как любопытно. Boolean занимает столько места в конечном счёте. Кто бы мог подумать?
Переходим к последнему пункту и используем команду "Удалить все объекты" программы.
Как ни странно, количество объектов и занимаемая память только выросли, как и количество используемых классов. Однако используемые нами основные объекты класса Item остались неизменны.

2. Перейдем к инструменту jstat и рассмотрим изменение в памяти в процессе добавления и удаления дополнительных заявок, используя команду "jstat -gc 11740 10s 999"
    2.0 Сразу после нового запуска приложения;
    2.1 После последовательного добавления нескольких десятков тысяч новых элементов;
    2.2 После удаления элементов;
Получаем следующий результат:
В ходе выполнения программы было добавлено дважды по 999999 объектов класса Item, а затем было произведено полное удаление объектов и однократное добавление 999999 объектов вновь.
Было замечено, что первое Survivor space не использовался вовсе. Видимо, это может говорить о том, что памяти компьютора достаточно, чтобы все "выжившие" объекты не выходили за пределы одного Survivor space.
Ожидаемо, количество объектов в Eden и Old Generation менялось в ходе выполнения программы, то вырастая, то уменьшаясь, однако в Metaspace количество только росло, но не значительно.
За время выполнения программы было произведено 14 малых сборок мусора, общим временем 0,174 секунды, а полных сборок мусора не производилось вовсе.
Однако, было произведено ещё 4 Concurent GC, и общее затраченное время на всю работу сборщиков 0,197 секунд.

3. Следующий же инструмент jconsole показывает нам загрузку процессора, загруженные классы, количество используемой памяти в процессе пользования программой.
Ожидаемо, сразу после запуска, количество используемой памяти устаканивается на определённой отметке, как и количество загруженных классов, а использование CPU колеблется от 0% до 0.3%.
В момент добавления 999999 объектов, количество использованной памяти возрастает и остается в верхней отметке, а использование процессора подскакивает и опускается обратно.
Аналогично происходит и во второй раз.
Однако, в момент удаления объектов, компьютер начинает ощутимо гудеть куллерами, а использование процессора подскакивает до 50+%.
После удаления объектов, использование процессора падает, однако, количество занятого места не уменьшается. Думаю, пока не сработал сборщик мусора.
Внесу ещё 999999 новых объектов. И, как я и ожидал, количество занятого места не увеличилось, а уменьшилось. Сработал сборщик мусора, удалил все неиспользуемые объекты и освободил место для новых.

Попробуем вывести программу за пределы памяти.
Добавили 9999999 объектов. Используемая память подскочила за 2ГБ + локальный всплеск использования CPU до 10%
Ещё одна попытка привела к ошибке "ArrayIndexOutOfBoundsException". Хм...